[배열]
-스택영역에 자료를 저장하고 컴파일시 공간을 확보한다.
장점 
1.자료를 순차적으로 저장가능
2.인덱스 번호로 접근 가능
->자료 접근과 저장이 빠르다.

단점
1.한번 확보된 배열의 크기 조절하기 어려움 -> 메모리 낭비
2.중간 값 삽입 삭제가 쉽지 않다.


[벡터]
-동적 배열 -> 배열 단점1 보완
-중간 값 삽입 삭제가 쉽지 않다. -> 배열 단점2
-데이터가 순차적으로 저장되어 검색속도가 빠르지 않다.
(위치를 안다면 배열처럼 쉽게 접근 가능함.)

[리스트]
-벡터의 단점인 중간값 삽입 삭제가 가능하다.
(포인터로 다음 값을 찾는 방식이므로 삽입/삭제가 용이하다.)
-데이터의 위치로 값에 접근할 수 없다.
-순차 접근이므로 검색 느리다.

[map]
-key와 value 한쌍인 트리구조
-자동 정렬이 된다.
-검색속도가 일렬 방식(list, vector)보다 빠르다.
-삽입 삭제가 빈번하면 항시 자동 정렬이 일어난다.

[set]
-map과 다르게 key만 저장한다.
-key를 빠르게 찾고 key가 정렬되기를 원할 때 사용할 수 있다.

*********************************************************

[hash table]
-hash_map과 hash_set이 사용하는 자료구조
-테이블에 자료를 저장할 때 키값을 해시 함수에 대입하여
버킷 번호가 나오면 그 버킷의 빈 슬롯에 자료를 저장한다.
-버킷 번호에 자료를 넣으므로 많은 자료를 저장해도 삽입/ 삭제/ 검색 속도가 일정.

[hash_map]
-많은 자료를 저장하여도 검색이 빠름. -> 반대로 자료의 양이 작으면 메모리 낭비, 검색시 오버헤드 발생.
-검색이 빠르다고 무분별하게 사용하면 안됨
->컨테이너를 추가 삭제하는 것은 list, vector가 훨씬 빠르다.
1. 적은 요소를 저장하여 검색하는 경우 -> vector, list
2. 많은 자료를 저장하여 검색하는 경우 -> hash_map

[hash_set]
-hash_map처럼 hash table을 자료구조로 사용
-key 저장 -> 정렬이 필요 없을 경우 사용.

<출처>
https://m.blog.naver.com/PostView.nhn?blogId=psd0217&logNo=220308769007&proxyReferer=https:%2F%2Fwww.google.com%2F